var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":true},"build":"automatic_transmission","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"/Users/ldy/git/sim2cpp/AT/automatic_transmission_ert_rtw","tag":"","groupDisplay":"Main file","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: ert_main.cpp\n//\n// Code generated for Simulink model 'automatic_transmission'.\n//\n// Model version                  : 15.5\n// Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n// C/C++ source code generated on : Wed Apr  9 13:54:16 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Apple->ARM64\n// Code generation objectives:\n//    1. Execution efficiency\n//    2. RAM efficiency\n// Validation result: Not run\n//\n#include <stdio.h>              // This example main program uses printf/fflush\n#include \"automatic_transmission.h\"    // Model header file\n\nstatic automatic_transmission rtObj;   // Instance of model class\n\n//\n// Associating rt_OneStep with a real-time clock or interrupt service routine\n// is what makes the generated code \"real-time\".  The function rt_OneStep is\n// always associated with the base rate of the model.  Subrates are managed\n// by the base rate from inside the generated code.  Enabling/disabling\n// interrupts and floating point context switches are target specific.  This\n// example code indicates where these should take place relative to executing\n// the generated code step function.  Overrun behavior should be tailored to\n// your application needs.  This example simply sets an error status in the\n// real-time model and returns from rt_OneStep.\n//\nvoid rt_OneStep(void);\nvoid rt_OneStep(void)\n{\n  static boolean_T OverrunFlag{ false };\n\n  // Disable interrupts here\n\n  // Check for overrun\n  if (OverrunFlag) {\n    rtObj.getRTM()->setErrorStatus(\"Overrun\");\n    return;\n  }\n\n  OverrunFlag = true;\n\n  // Save FPU context here (if necessary)\n  // Re-enable timer or interrupt here\n  // Set model inputs here\n\n  // Step the model\n  rtObj.step();\n\n  // Get model outputs here\n\n  // Indicate task complete\n  OverrunFlag = false;\n\n  // Disable interrupts here\n  // Restore FPU context here (if necessary)\n  // Enable interrupts here\n}\n\n//\n// The example main function illustrates what is required by your\n// application code to initialize, execute, and terminate the generated code.\n// Attaching rt_OneStep to a real-time clock is target specific. This example\n// illustrates how you do this relative to initializing the model.\n//\nint_T main(int_T argc, const char *argv[])\n{\n  // Unused arguments\n  (void)(argc);\n  (void)(argv);\n\n  // Initialize model\n  rtObj.initialize();\n\n  // Simulating the model step behavior (in non real-time) to\n  //   simulate model behavior at stop time.\n\n  while (rtObj.getRTM()->getErrorStatus() == (nullptr)&& !rtObj.getRTM()\n         ->getStopRequested()) {\n    rt_OneStep();\n  }\n\n  return 0;\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"automatic_transmission.cpp","type":"source","group":"model","path":"/Users/ldy/git/sim2cpp/AT/automatic_transmission_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: automatic_transmission.cpp\n//\n// Code generated for Simulink model 'automatic_transmission'.\n//\n// Model version                  : 15.5\n// Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n// C/C++ source code generated on : Wed Apr  9 13:54:16 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Apple->ARM64\n// Code generation objectives:\n//    1. Execution efficiency\n//    2. RAM efficiency\n// Validation result: Not run\n//\n#include \"automatic_transmission.h\"\n#include \"rtwtypes.h\"\n#include <cmath>\n#include \"rt_look.h\"\n#include \"cmath\"\n#include \"limits\"\n\n// Named constants for Chart: '<Root>/ShiftLogic'\nconst int32_T CALL_EVENT{ -1 };\n\nconst uint8_T IN_downshifting{ 1U };\n\nconst uint8_T IN_first{ 1U };\n\nconst uint8_T IN_fourth{ 2U };\n\nconst uint8_T IN_second{ 3U };\n\nconst uint8_T IN_steady_state{ 2U };\n\nconst uint8_T IN_third{ 4U };\n\nconst uint8_T IN_upshifting{ 3U };\n\nconst int32_T event_DOWN{ 30 };\n\nconst int32_T event_UP{ 31 };\n\nextern real_T rt_powd_snf(real_T u0, real_T u1);\n\n// private model entry point functions\nextern void automatic_transmission_derivatives();\nstatic void rate_scheduler(automatic_transmission::RT_MODEL *const rtM);\nextern \"C\"\n{\n\n#ifndef INTERP\n#define INTERP(x,x1,x2,y1,y2)          ( (y1)+(((y2) - (y1))/((x2) - (x1)))*((x)-(x1)) )\n#endif\n\n#ifndef ZEROTECHNIQUE\n#define ZEROTECHNIQUE\n\n  enum class ZeroTechnique : int_T {\n    NORMAL_INTERP,\n    AVERAGE_VALUE,\n    MIDDLE_VALUE\n  };\n\n#endif\n\n  static int_T rt_GetLookupIndex(const real_T *x, int_T xlen, real_T u) ;\n}                                      // extern \"C\"\n\nextern \"C\"\n{\n  static real_T rt_Lookup(const real_T *x, int_T xlen, real_T u, const real_T *y);\n}                                      // extern \"C\"\n\nextern \"C\"\n{\n  static real_T rt_Lookup2D_Normal (const real_T *xVals, const int_T numX,\n    const real_T *yVals, const int_T numY,\n    const real_T *zVals,\n    const real_T x, const real_T y);\n}                                      // extern \"C\"\n\nextern \"C\"\n{\n  real_T rtNaN { -std::numeric_limits<real_T>::quiet_NaN() };\n\n  real_T rtInf { std::numeric_limits<real_T>::infinity() };\n\n  real_T rtMinusInf { -std::numeric_limits<real_T>::infinity() };\n\n  real32_T rtNaNF { -std::numeric_limits<real32_T>::quiet_NaN() };\n\n  real32_T rtInfF { std::numeric_limits<real32_T>::infinity() };\n\n  real32_T rtMinusInfF { -std::numeric_limits<real32_T>::infinity() };\n}\n\nextern \"C\"\n{\n  // Return rtInf needed by the generated code.\n  static real_T rtGetInf(void)\n  {\n    return rtInf;\n  }\n\n  // Get rtInfF needed by the generated code.\n  static real32_T rtGetInfF(void)\n  {\n    return rtInfF;\n  }\n\n  // Return rtMinusInf needed by the generated code.\n  static real_T rtGetMinusInf(void)\n  {\n    return rtMinusInf;\n  }\n\n  // Return rtMinusInfF needed by the generated code.\n  static real32_T rtGetMinusInfF(void)\n  {\n    return rtMinusInfF;\n  }\n}\n\nextern \"C\"\n{\n  // Return rtNaN needed by the generated code.\n  static real_T rtGetNaN(void)\n  {\n    return rtNaN;\n  }\n\n  // Return rtNaNF needed by the generated code.\n  static real32_T rtGetNaNF(void)\n  {\n    return rtNaNF;\n  }\n}\n\nextern \"C\"\n{\n  //\n  // Routine to get the index of the input from a table using binary or\n  // interpolation search.\n  //\n  // Inputs:\n  // *x   : Pointer to table, x[0] ....x[xlen-1]\n  // xlen : Number of values in xtable\n  // u    : input value to look up\n  //\n  // Output:\n  // idx  : the index into the table such that:\n  // if u is negative\n  // x[idx] <= u < x[idx+1]\n  // else\n  // x[idx] < u <= x[idx+1]\n  //\n  // Interpolation Search: If the table contains a large number of nearly\n  // uniformly spaced entries, i.e., x[n] vs n is linear then the index\n  // corresponding to the input can be found in one shot using the linear\n  // interpolation formula. Therefore if you have a look-up table block with\n  // many data points, using interpolation search might speed up the code.\n  // Compile the generated code with the following flag:\n  //\n  // make_rtw OPTS=-DDOINTERPSEARCH\n  //\n  // to enable interpolation search.\n  //\n  static int_T rt_GetLookupIndex(const real_T *x, int_T xlen, real_T u)\n  {\n    int_T idx{ 0 };\n\n    int_T bottom{ 0 };\n\n    int_T top{ xlen-1 };\n\n    int_T retValue{ 0 };\n\n    boolean_T returnStatus{ 0U };\n\n#ifdef DOINTERPSEARCH\n\n    real_T offset{ 0 };\n\n#endif\n\n    //\n    //  Deal with the extreme cases first:\n    //    if u <= x[bottom] then return idx = bottom\n    //    if u >= x[top]    then return idx = top-1\n\n    if (u <= x[bottom]) {\n      retValue = bottom;\n      returnStatus = 1U;\n    } else if (u >= x[top]) {\n      retValue = top-1;\n      returnStatus = 1U;\n    } else {\n      // else required to ensure safe programming, even *\n      //  if it's expected that it will never be reached\n    }\n\n    if (returnStatus == 0U) {\n      if (u < 0) {\n        // For negative input find index such that: x[idx] <= u < x[idx+1]\n        for (;;) {\n\n#ifdef DOINTERPSEARCH\n\n          offset = (u-x[bottom])/(x[top]-x[bottom]);\n          idx = bottom + (int_T)((top-bottom)*(offset-DBL_EPSILON));\n\n#else\n\n          idx = (bottom + top)/2;\n\n#endif\n\n          if (u < x[idx]) {\n            top = idx - 1;\n          } else if (u >= x[idx+1]) {\n            bottom = idx + 1;\n          } else {\n            // we have x[idx] <= u < x[idx+1], return idx\n            retValue = idx;\n            break;\n          }\n        }\n      } else {\n        // For non-negative input find index such that: x[idx] < u <= x[idx+1]\n        for (;;) {\n\n#ifdef DOINTERPSEARCH\n\n          offset = (u-x[bottom])/(x[top]-x[bottom]);\n          idx = bottom + (int_T)((top-bottom)*(offset-DBL_EPSILON));\n\n#else\n\n          idx = (bottom + top)/2;\n\n#endif\n\n          if (u <= x[idx]) {\n            top = idx - 1;\n          } else if (u > x[idx+1]) {\n            bottom = idx + 1;\n          } else {\n            // we have x[idx] < u <= x[idx+1], return idx\n            retValue = idx;\n            break;\n          }\n        }\n      }\n    }\n\n    return retValue;\n  }\n}                                      // extern \"C\"\n\nextern \"C\"\n{\n  // 1D lookup routine for data type of real_T.\n  static real_T rt_Lookup(const real_T *x, int_T xlen, real_T u, const real_T *y)\n  {\n    int_T idx{ rt_GetLookupIndex(x, xlen, u) };\n\n    real_T num{ y[idx+1] - y[idx] };\n\n    real_T den{ x[idx+1] - x[idx] };\n\n    // Due to the way the binary search is implemented\n    // in rt_look.c (rt_GetLookupIndex), den cannot be\n    // 0.  Equivalently, m cannot be inf or nan.\n    real_T m{ num/den };\n\n    return (y[idx] + (m * (u - x[idx])));\n  }\n}                                      // extern \"C\"\n\nextern \"C\"\n{\n  // 2D normal lookup routine for data type of real_T.\n  static real_T rt_Lookup2D_Normal(const real_T *xVals, const int_T numX,\n    const real_T *yVals, const int_T numY,\n    const real_T *zVals,\n    const real_T x, const real_T y)\n  {\n    int_T xIdx, yIdx;\n    real_T ylo, yhi;\n    real_T Zx0yhi, Zx0ylo, xlo, xhi;\n    real_T corner1, corner2;\n    xIdx = rt_GetLookupIndex(xVals,numX,x);\n    xlo = xVals[xIdx];\n    xhi = xVals[xIdx+1];\n    yIdx = rt_GetLookupIndex(yVals,numY,y);\n    ylo = yVals[yIdx];\n    yhi = yVals[yIdx+1];\n    corner1 = *(zVals + xIdx + (numX * yIdx));\n    corner2 = *(zVals + (xIdx+1) + (numX * yIdx));\n    Zx0ylo = INTERP(x, xlo, xhi, corner1, corner2);\n    corner1 = *(zVals + xIdx + (numX * (yIdx+1)));\n    corner2 = *(zVals + (xIdx+1) + (numX*(yIdx+1)));\n    Zx0yhi = INTERP(x, xlo, xhi, corner1, corner2);\n    return (INTERP(y,ylo,yhi,Zx0ylo,Zx0yhi));\n  }\n}                                      // extern \"C\"\n\nextern \"C\"\n{\n  // Test if value is infinite\n  static boolean_T rtIsInf(real_T value)\n  {\n    return std::isinf(value);\n  }\n\n  // Test if single-precision value is infinite\n  static boolean_T rtIsInfF(real32_T value)\n  {\n    return std::isinf(value);\n  }\n\n  // Test if value is not a number\n  static boolean_T rtIsNaN(real_T value)\n  {\n    return std::isnan(value);\n  }\n\n  // Test if single-precision value is not a number\n  static boolean_T rtIsNaNF(real32_T value)\n  {\n    return std::isnan(value);\n  }\n}\n\n//\n//         This function updates active task flag for each subrate.\n//         The function is called at model base rate, hence the\n//         generated code self-manages all its subrates.\n//\nstatic void rate_scheduler(automatic_transmission::RT_MODEL *const rtM)\n{\n  // Compute which subrates run during the next base time step.  Subrates\n  //  are an integer multiple of the base rate counter.  Therefore, the subtask\n  //  counter is reset when it reaches its limit (zero means run).\n\n  (rtM->Timing.TaskCounters.TID[2])++;\n  if ((rtM->Timing.TaskCounters.TID[2]) > 3) {// Sample time: [0.04s, 0.0s]\n    rtM->Timing.TaskCounters.TID[2] = 0;\n  }\n}\n\n//\n// This function updates continuous states using the ODE3 fixed-step\n// solver algorithm\n//\nvoid automatic_transmission::rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\n{\n  // Solver Matrices\n  static const real_T rt_ODE3_A[3]{\n    1.0/2.0, 3.0/4.0, 1.0\n  };\n\n  static const real_T rt_ODE3_B[3][3]{\n    { 1.0/2.0, 0.0, 0.0 },\n\n    { 0.0, 3.0/4.0, 0.0 },\n\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\n  };\n\n  time_T t { rtsiGetT(si) };\n\n  time_T tnew { rtsiGetSolverStopTime(si) };\n\n  time_T h { rtsiGetStepSize(si) };\n\n  real_T *x { rtsiGetContStates(si) };\n\n  ODE3_IntgData *id { static_cast<ODE3_IntgData *>(rtsiGetSolverData(si)) };\n\n  real_T *y { id->y };\n\n  real_T *f0 { id->f[0] };\n\n  real_T *f1 { id->f[1] };\n\n  real_T *f2 { id->f[2] };\n\n  real_T hB[3];\n  int_T i;\n  int_T nXc { 2 };\n\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n  // Save the state values at time t in y, we'll use x as ynew.\n  (void) std::memcpy(y, x,\n                     static_cast<uint_T>(nXc)*sizeof(real_T));\n\n  // Assumes that rtsiSetT and ModelOutputs are up-to-date\n  // f0 = f(t,y)\n  rtsiSetdX(si, f0);\n  automatic_transmission_derivatives();\n\n  // f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*));\n  hB[0] = h * rt_ODE3_B[0][0];\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\n  rtsiSetdX(si, f1);\n  this->step();\n  automatic_transmission_derivatives();\n\n  // f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*));\n  for (i = 0; i <= 1; i++) {\n    hB[i] = h * rt_ODE3_B[1][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\n  rtsiSetdX(si, f2);\n  this->step();\n  automatic_transmission_derivatives();\n\n  // tnew = t + hA(3);\n  // ynew = y + f*hB(:,3);\n  for (i = 0; i <= 2; i++) {\n    hB[i] = h * rt_ODE3_B[2][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\n  }\n\n  rtsiSetT(si, tnew);\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\n// Function for Chart: '<Root>/ShiftLogic'\nvoid automatic_transmission::gear_state(const int32_T *sfEvent)\n{\n  switch (rtDW.is_gear_state) {\n   case IN_first:\n    rtDW.gear = 1.0;\n    if (*sfEvent == event_UP) {\n      rtDW.is_gear_state = IN_second;\n      rtDW.gear = 2.0;\n    }\n    break;\n\n   case IN_fourth:\n    rtDW.gear = 4.0;\n    if (*sfEvent == event_DOWN) {\n      rtDW.is_gear_state = IN_third;\n      rtDW.gear = 3.0;\n    }\n    break;\n\n   case IN_second:\n    rtDW.gear = 2.0;\n    switch (*sfEvent) {\n     case event_UP:\n      rtDW.is_gear_state = IN_third;\n      rtDW.gear = 3.0;\n      break;\n\n     case event_DOWN:\n      rtDW.is_gear_state = IN_first;\n      rtDW.gear = 1.0;\n      break;\n    }\n    break;\n\n   case IN_third:\n    rtDW.gear = 3.0;\n    switch (*sfEvent) {\n     case event_UP:\n      rtDW.is_gear_state = IN_fourth;\n      rtDW.gear = 4.0;\n      break;\n\n     case event_DOWN:\n      rtDW.is_gear_state = IN_second;\n      rtDW.gear = 2.0;\n      break;\n    }\n    break;\n  }\n}\n\nreal_T rt_powd_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  if (std::isnan(u0) || std::isnan(u1)) {\n    y = (rtNaN);\n  } else {\n    real_T tmp;\n    real_T tmp_0;\n    tmp = std::abs(u0);\n    tmp_0 = std::abs(u1);\n    if (std::isinf(u1)) {\n      if (tmp == 1.0) {\n        y = 1.0;\n      } else if (tmp > 1.0) {\n        if (u1 > 0.0) {\n          y = (rtInf);\n        } else {\n          y = 0.0;\n        }\n      } else if (u1 > 0.0) {\n        y = 0.0;\n      } else {\n        y = (rtInf);\n      }\n    } else if (tmp_0 == 0.0) {\n      y = 1.0;\n    } else if (tmp_0 == 1.0) {\n      if (u1 > 0.0) {\n        y = u0;\n      } else {\n        y = 1.0 / u0;\n      }\n    } else if (u1 == 2.0) {\n      y = u0 * u0;\n    } else if ((u1 == 0.5) && (u0 >= 0.0)) {\n      y = std::sqrt(u0);\n    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {\n      y = (rtNaN);\n    } else {\n      y = std::pow(u0, u1);\n    }\n  }\n\n  return y;\n}\n\n// Model step function\nvoid automatic_transmission::step()\n{\n  real_T interp_down;\n  real_T interp_up;\n  int32_T sfEvent;\n  if ((&rtM)->isMajorTimeStep()) {\n    // set solver stop time\n    rtsiSetSolverStopTime(&(&rtM)->solverInfo,(((&rtM)->Timing.clockTick0+1)*\n      (&rtM)->Timing.stepSize0));\n  }                                    // end MajorTimeStep\n\n  // Update absolute time of base rate at minor time step\n  if ((&rtM)->isMinorTimeStep()) {\n    (&rtM)->Timing.t[0] = rtsiGetT(&(&rtM)->solverInfo);\n  }\n\n  // Gain: '<S5>/mph' incorporates:\n  //   Gain: '<S5>/LinearSpeed'\n  //   Integrator: '<S5>/Wheel Speed'\n\n  rtDW.VehicleSpeed = 6.2831853071795862 * rtX.WheelSpeed_CSTATE *\n    0.011363636363636364;\n\n  // Outport: '<Root>/speed'\n  rtY.speed = rtDW.VehicleSpeed;\n\n  // Integrator: '<S1>/Integrator'\n  // Limited  Integrator\n  if (rtX.Integrator_CSTATE >= 6000.0) {\n    rtX.Integrator_CSTATE = 6000.0;\n  } else if (rtX.Integrator_CSTATE <= 600.0) {\n    rtX.Integrator_CSTATE = 600.0;\n  }\n\n  // Outport: '<Root>/RPM' incorporates:\n  //   Integrator: '<S1>/Integrator'\n\n  rtY.RPM = rtX.Integrator_CSTATE;\n  if ((&rtM)->isMajorTimeStep() &&\n      (&rtM)->Timing.TaskCounters.TID[2] == 0) {\n    // Chart: '<Root>/ShiftLogic'\n    sfEvent = CALL_EVENT;\n    if (rtDW.temporalCounter_i1 < MAX_uint32_T) {\n      rtDW.temporalCounter_i1++;\n    }\n\n    if (rtDW.is_active_c1_automatic_transmis == 0) {\n      rtDW.is_active_c1_automatic_transmis = 1U;\n      rtDW.is_active_gear_state = 1U;\n      rtDW.is_gear_state = IN_first;\n      rtDW.gear = 1.0;\n      rtDW.is_active_selection_state = 1U;\n      rtDW.is_selection_state = IN_steady_state;\n    } else {\n      if (rtDW.is_active_gear_state != 0) {\n        gear_state(&sfEvent);\n      }\n\n      if (rtDW.is_active_selection_state != 0) {\n        // Outputs for Function Call SubSystem: '<Root>/ThresholdCalculation'\n        // Lookup2D: '<S3>/interp_down' incorporates:\n        //   Inport: '<Root>/throttle'\n\n        interp_down = rt_Lookup2D_Normal(&rtConstP.interp_down_RowIdx[0], 6,\n          &rtConstP.pooled1[0], 4, &rtConstP.interp_down_Table[0], rtU.throttle,\n          rtDW.gear);\n\n        // Lookup2D: '<S3>/interp_up' incorporates:\n        //   Inport: '<Root>/throttle'\n\n        interp_up = rt_Lookup2D_Normal(&rtConstP.interp_up_RowIdx[0], 6,\n          &rtConstP.pooled1[0], 4, &rtConstP.interp_up_Table[0], rtU.throttle,\n          rtDW.gear);\n\n        // End of Outputs for SubSystem: '<Root>/ThresholdCalculation'\n        switch (rtDW.is_selection_state) {\n         case IN_downshifting:\n          if ((rtDW.temporalCounter_i1 >= 2U) && (rtDW.VehicleSpeed <=\n               interp_down)) {\n            sfEvent = event_DOWN;\n            if (rtDW.is_active_gear_state != 0) {\n              gear_state(&sfEvent);\n            }\n\n            rtDW.is_selection_state = IN_steady_state;\n          } else if (rtDW.VehicleSpeed > interp_down) {\n            rtDW.is_selection_state = IN_steady_state;\n          }\n          break;\n\n         case IN_steady_state:\n          if (rtDW.VehicleSpeed > interp_up) {\n            rtDW.temporalCounter_i1 = 0U;\n            rtDW.is_selection_state = IN_upshifting;\n          } else if (rtDW.VehicleSpeed < interp_down) {\n            rtDW.temporalCounter_i1 = 0U;\n            rtDW.is_selection_state = IN_downshifting;\n          }\n          break;\n\n         case IN_upshifting:\n          if ((rtDW.temporalCounter_i1 >= 2U) && (rtDW.VehicleSpeed >= interp_up))\n          {\n            sfEvent = event_UP;\n            if (rtDW.is_active_gear_state != 0) {\n              gear_state(&sfEvent);\n            }\n\n            rtDW.is_selection_state = IN_steady_state;\n          } else if (rtDW.VehicleSpeed < interp_up) {\n            rtDW.is_selection_state = IN_steady_state;\n          }\n          break;\n        }\n      }\n    }\n\n    // End of Chart: '<Root>/ShiftLogic'\n\n    // Outport: '<Root>/gear'\n    rtY.gear = rtDW.gear;\n\n    // Lookup: '<S7>/Look-Up Table'\n    rtDW.LookUpTable = rt_Lookup(&rtConstP.pooled1[0], 4, rtDW.gear,\n      &rtConstP.LookUpTable_YData[0]);\n  }\n\n  // Gain: '<S5>/FinalDriveRatio2' incorporates:\n  //   Integrator: '<S5>/Wheel Speed'\n\n  rtDW.TransmissionRPM = 3.23 * rtX.WheelSpeed_CSTATE;\n\n  // Product: '<S6>/SpeedRatio' incorporates:\n  //   Integrator: '<S1>/Integrator'\n  //   Product: '<S7>/Product1'\n\n  interp_down = rtDW.LookUpTable * rtDW.TransmissionRPM / rtX.Integrator_CSTATE;\n\n  // Fcn: '<S6>/Impeller' incorporates:\n  //   Integrator: '<S1>/Integrator'\n  //   Lookup: '<S6>/FactorK'\n  //   Product: '<S6>/Quotient'\n\n  interp_up = rt_powd_snf(rtX.Integrator_CSTATE / rt_Lookup(&rtConstP.pooled3[0],\n    21, interp_down, &rtConstP.FactorK_YData[0]), 2.0);\n\n  // Gain: '<S1>/engine + impeller inertia' incorporates:\n  //   Fcn: '<S6>/Impeller'\n  //   Inport: '<Root>/throttle'\n  //   Integrator: '<S1>/Integrator'\n  //   Lookup2D: '<S1>/EngineTorque'\n  //   Sum: '<S1>/Sum'\n\n  rtDW.engineimpellerinertia = (rt_Lookup2D_Normal\n    (&rtConstP.EngineTorque_RowIdx[0], 10, &rtConstP.EngineTorque_ColIdx[0], 11,\n     &rtConstP.EngineTorque_Table[0], rtU.throttle, rtX.Integrator_CSTATE) -\n    interp_up) * 45.472138452209627;\n\n  // Product: '<S7>/Product' incorporates:\n  //   Fcn: '<S6>/Impeller'\n  //   Lookup: '<S6>/TorqueRatio'\n  //   Product: '<S6>/Turbine'\n\n  rtDW.OutputTorque = interp_up * rt_Lookup(&rtConstP.pooled3[0], 21,\n    interp_down, &rtConstP.TorqueRatio_YData[0]) * rtDW.LookUpTable;\n\n  // Signum: '<S5>/Sign'\n  if (std::isnan(rtDW.VehicleSpeed)) {\n    interp_down = (rtNaN);\n  } else if (rtDW.VehicleSpeed < 0.0) {\n    interp_down = -1.0;\n  } else {\n    interp_down = (rtDW.VehicleSpeed > 0.0);\n  }\n\n  // Gain: '<S5>/Vehicle Inertia' incorporates:\n  //   Fcn: '<S5>/RoadLoad'\n  //   Gain: '<S5>/Final Drive Ratio1'\n  //   Inport: '<Root>/brake'\n  //   Product: '<S5>/SignedLoad'\n  //   Signum: '<S5>/Sign'\n  //   Sum: '<S5>/Sum'\n  //   Sum: '<S5>/Sum1'\n\n  rtDW.VehicleInertia = (3.23 * rtDW.OutputTorque - ((0.02 * rt_powd_snf\n    (rtDW.VehicleSpeed, 2.0) + 40.0) + rtU.brake) * interp_down) *\n    0.082684618362373577;\n  if ((&rtM)->isMajorTimeStep()) {\n    rt_ertODEUpdateContinuousStates(&(&rtM)->solverInfo);\n\n    // Update absolute time for base rate\n    // The \"clockTick0\" counts the number of times the code of this task has\n    //  been executed. The absolute time is the multiplication of \"clockTick0\"\n    //  and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n    //  overflow during the application lifespan selected.\n\n    ++(&rtM)->Timing.clockTick0;\n    (&rtM)->Timing.t[0] = rtsiGetSolverStopTime(&(&rtM)->solverInfo);\n\n    {\n      // Update absolute timer for sample time: [0.01s, 0.0s]\n      // The \"clockTick1\" counts the number of times the code of this task has\n      //  been executed. The resolution of this integer timer is 0.01, which is the step size\n      //  of the task. Size of \"clockTick1\" ensures timer will not overflow during the\n      //  application lifespan selected.\n\n      (&rtM)->Timing.clockTick1++;\n    }\n\n    rate_scheduler((&rtM));\n  }                                    // end MajorTimeStep\n}\n\n// Derivatives for root system: '<Root>'\nvoid automatic_transmission::automatic_transmission_derivatives()\n{\n  automatic_transmission::XDot *_rtXdot;\n  boolean_T lsat;\n  boolean_T usat;\n  _rtXdot = ((XDot *) (&rtM)->derivs);\n\n  // Derivatives for Integrator: '<S5>/Wheel Speed'\n  _rtXdot->WheelSpeed_CSTATE = rtDW.VehicleInertia;\n\n  // Derivatives for Integrator: '<S1>/Integrator'\n  lsat = (rtX.Integrator_CSTATE <= 600.0);\n  usat = (rtX.Integrator_CSTATE >= 6000.0);\n  if (((!lsat) && (!usat)) || (lsat && (rtDW.engineimpellerinertia > 0.0)) ||\n      (usat && (rtDW.engineimpellerinertia < 0.0))) {\n    _rtXdot->Integrator_CSTATE = rtDW.engineimpellerinertia;\n  } else {\n    // in saturation\n    _rtXdot->Integrator_CSTATE = 0.0;\n  }\n\n  // End of Derivatives for Integrator: '<S1>/Integrator'\n}\n\n// Model initialize function\nvoid automatic_transmission::initialize()\n{\n  // Registration code\n  {\n    // Setup solver object\n    rtsiSetSimTimeStepPtr(&(&rtM)->solverInfo, &(&rtM)->Timing.simTimeStep);\n    rtsiSetTPtr(&(&rtM)->solverInfo, (&rtM)->getTPtrPtr());\n    rtsiSetStepSizePtr(&(&rtM)->solverInfo, &(&rtM)->Timing.stepSize0);\n    rtsiSetdXPtr(&(&rtM)->solverInfo, &(&rtM)->derivs);\n    rtsiSetContStatesPtr(&(&rtM)->solverInfo, (real_T **) &(&rtM)->contStates);\n    rtsiSetNumContStatesPtr(&(&rtM)->solverInfo, &(&rtM)->Sizes.numContStates);\n    rtsiSetNumPeriodicContStatesPtr(&(&rtM)->solverInfo, &(&rtM)\n      ->Sizes.numPeriodicContStates);\n    rtsiSetPeriodicContStateIndicesPtr(&(&rtM)->solverInfo, &(&rtM)\n      ->periodicContStateIndices);\n    rtsiSetPeriodicContStateRangesPtr(&(&rtM)->solverInfo, &(&rtM)\n      ->periodicContStateRanges);\n    rtsiSetContStateDisabledPtr(&(&rtM)->solverInfo, (boolean_T**) &(&rtM)\n      ->contStateDisabled);\n    rtsiSetErrorStatusPtr(&(&rtM)->solverInfo, (&rtM)->getErrorStatusPtr());\n    rtsiSetRTModelPtr(&(&rtM)->solverInfo, (&rtM));\n  }\n\n  rtsiSetSimTimeStep(&(&rtM)->solverInfo, MAJOR_TIME_STEP);\n  rtsiSetIsMinorTimeStepWithModeChange(&(&rtM)->solverInfo, false);\n  rtsiSetIsContModeFrozen(&(&rtM)->solverInfo, false);\n  (&rtM)->intgData.y = (&rtM)->odeY;\n  (&rtM)->intgData.f[0] = (&rtM)->odeF[0];\n  (&rtM)->intgData.f[1] = (&rtM)->odeF[1];\n  (&rtM)->intgData.f[2] = (&rtM)->odeF[2];\n  (&rtM)->contStates = ((X *) &rtX);\n  (&rtM)->contStateDisabled = ((XDis *) &rtXDis);\n  (&rtM)->Timing.tStart = (0.0);\n  rtsiSetSolverData(&(&rtM)->solverInfo, static_cast<void *>(&(&rtM)->intgData));\n  rtsiSetSolverName(&(&rtM)->solverInfo,\"ode3\");\n  (&rtM)->setTPtr(&(&rtM)->Timing.tArray[0]);\n  (&rtM)->Timing.stepSize0 = 0.01;\n\n  // InitializeConditions for Integrator: '<S5>/Wheel Speed'\n  rtX.WheelSpeed_CSTATE = 0.0;\n\n  // InitializeConditions for Integrator: '<S1>/Integrator'\n  rtX.Integrator_CSTATE = 1000.0;\n}\n\ntime_T** automatic_transmission::RT_MODEL::getTPtrPtr()\n{\n  return &(Timing.t);\n}\n\ntime_T* automatic_transmission::RT_MODEL::getTPtr() const\n{\n  return (Timing.t);\n}\n\nvoid automatic_transmission::RT_MODEL::setTPtr(time_T* aTPtr)\n{\n  (Timing.t = aTPtr);\n}\n\nboolean_T automatic_transmission::RT_MODEL::isMinorTimeStep() const\n{\n  return ((Timing.simTimeStep) == MINOR_TIME_STEP);\n}\n\nboolean_T automatic_transmission::RT_MODEL::getStopRequested() const\n{\n  return (Timing.stopRequestedFlag);\n}\n\nvoid automatic_transmission::RT_MODEL::setStopRequested(boolean_T aStopRequested)\n{\n  (Timing.stopRequestedFlag = aStopRequested);\n}\n\nboolean_T automatic_transmission::RT_MODEL::isMajorTimeStep() const\n{\n  return ((Timing.simTimeStep) == MAJOR_TIME_STEP);\n}\n\nboolean_T* automatic_transmission::RT_MODEL::getStopRequestedPtr()\n{\n  return (&(Timing.stopRequestedFlag));\n}\n\nconst char_T** automatic_transmission::RT_MODEL::getErrorStatusPtr()\n{\n  return &errorStatus;\n}\n\ntime_T automatic_transmission::RT_MODEL::getTStart() const\n{\n  return (Timing.tStart);\n}\n\nconst char_T* automatic_transmission::RT_MODEL::getErrorStatus() const\n{\n  return (errorStatus);\n}\n\nvoid automatic_transmission::RT_MODEL::setErrorStatus(const char_T* const\n  aErrorStatus)\n{\n  (errorStatus = aErrorStatus);\n}\n\n// Constructor\nautomatic_transmission::automatic_transmission() :\n  rtU(),\n  rtY(),\n  rtDW(),\n  rtX(),\n  rtXDis(),\n  rtM()\n{\n  // Currently there is no constructor body generated.\n}\n\n// Destructor\n// Currently there is no destructor body generated.\nautomatic_transmission::~automatic_transmission() = default;\n\n// Real-Time Model get method\nautomatic_transmission::RT_MODEL * automatic_transmission::getRTM()\n{\n  return (&rtM);\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"automatic_transmission.h","type":"header","group":"model","path":"/Users/ldy/git/sim2cpp/AT/automatic_transmission_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: automatic_transmission.h\n//\n// Code generated for Simulink model 'automatic_transmission'.\n//\n// Model version                  : 15.5\n// Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n// C/C++ source code generated on : Wed Apr  9 13:54:16 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Apple->ARM64\n// Code generation objectives:\n//    1. Execution efficiency\n//    2. RAM efficiency\n// Validation result: Not run\n//\n#ifndef automatic_transmission_h_\n#define automatic_transmission_h_\n#include <cmath>\n#include \"rtwtypes.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#include <cstring>\n#ifndef ODE3_INTG\n#define ODE3_INTG\n\n// ODE3 Integration Data\nstruct ODE3_IntgData {\n  real_T *y;                           // output\n  real_T *f[3];                        // derivatives\n};\n\n#endif\n\nextern \"C\"\n{\n  static real_T rtGetInf(void);\n  static real32_T rtGetInfF(void);\n  static real_T rtGetMinusInf(void);\n  static real32_T rtGetMinusInfF(void);\n}                                      // extern \"C\"\n\nextern \"C\"\n{\n  static real_T rtGetNaN(void);\n  static real32_T rtGetNaNF(void);\n}                                      // extern \"C\"\n\nextern \"C\"\n{\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  static boolean_T rtIsInf(real_T value);\n  static boolean_T rtIsInfF(real32_T value);\n  static boolean_T rtIsNaN(real_T value);\n  static boolean_T rtIsNaNF(real32_T value);\n}                                      // extern \"C\"\n\n// Class declaration for model automatic_transmission\nclass automatic_transmission final\n{\n  // public data and function members\n public:\n  // Block signals and states (default storage) for system '<Root>'\n  struct DW {\n    real_T VehicleSpeed;               // '<S5>/mph'\n    real_T LookUpTable;                // '<S7>/Look-Up Table'\n    real_T TransmissionRPM;            // '<S5>/FinalDriveRatio2'\n    real_T engineimpellerinertia;      // '<S1>/engine + impeller inertia'\n    real_T OutputTorque;               // '<S7>/Product'\n    real_T VehicleInertia;             // '<S5>/Vehicle Inertia'\n    real_T gear;                       // '<Root>/ShiftLogic'\n    uint32_T temporalCounter_i1;       // '<Root>/ShiftLogic'\n    uint8_T is_active_c1_automatic_transmis;// '<Root>/ShiftLogic'\n    uint8_T is_active_gear_state;      // '<Root>/ShiftLogic'\n    uint8_T is_gear_state;             // '<Root>/ShiftLogic'\n    uint8_T is_active_selection_state; // '<Root>/ShiftLogic'\n    uint8_T is_selection_state;        // '<Root>/ShiftLogic'\n  };\n\n  // Continuous states (default storage)\n  struct X {\n    real_T WheelSpeed_CSTATE;          // '<S5>/Wheel Speed'\n    real_T Integrator_CSTATE;          // '<S1>/Integrator'\n  };\n\n  // State derivatives (default storage)\n  struct XDot {\n    real_T WheelSpeed_CSTATE;          // '<S5>/Wheel Speed'\n    real_T Integrator_CSTATE;          // '<S1>/Integrator'\n  };\n\n  // State disabled\n  struct XDis {\n    boolean_T WheelSpeed_CSTATE;       // '<S5>/Wheel Speed'\n    boolean_T Integrator_CSTATE;       // '<S1>/Integrator'\n  };\n\n  // Constant parameters (default storage)\n  struct ConstP {\n    // Expression: downth\n    //  Referenced by: '<S3>/interp_down'\n\n    real_T interp_down_RowIdx[6];\n\n    // Pooled Parameter (Mixed Expressions)\n    //  Referenced by:\n    //    '<S3>/interp_down'\n    //    '<S3>/interp_up'\n    //    '<S7>/Look-Up Table'\n\n    real_T pooled1[4];\n\n    // Expression: downtab\n    //  Referenced by: '<S3>/interp_down'\n\n    real_T interp_down_Table[24];\n\n    // Expression: upth\n    //  Referenced by: '<S3>/interp_up'\n\n    real_T interp_up_RowIdx[6];\n\n    // Expression: uptab\n    //  Referenced by: '<S3>/interp_up'\n\n    real_T interp_up_Table[24];\n\n    // Expression: thvec\n    //  Referenced by: '<S1>/EngineTorque'\n\n    real_T EngineTorque_RowIdx[10];\n\n    // Expression: nevec\n    //  Referenced by: '<S1>/EngineTorque'\n\n    real_T EngineTorque_ColIdx[11];\n\n    // Expression: emap\n    //  Referenced by: '<S1>/EngineTorque'\n\n    real_T EngineTorque_Table[110];\n\n    // Expression: [2.393 1.450 1.000 0.677]\n    //  Referenced by: '<S7>/Look-Up Table'\n\n    real_T LookUpTable_YData[4];\n\n    // Pooled Parameter (Expression: speedratio)\n    //  Referenced by:\n    //    '<S6>/FactorK'\n    //    '<S6>/TorqueRatio'\n\n    real_T pooled3[21];\n\n    // Expression: Kfactor\n    //  Referenced by: '<S6>/FactorK'\n\n    real_T FactorK_YData[21];\n\n    // Expression: Torkratio\n    //  Referenced by: '<S6>/TorqueRatio'\n\n    real_T TorqueRatio_YData[21];\n  };\n\n  // External inputs (root inport signals with default storage)\n  struct ExtU {\n    real_T throttle;                   // '<Root>/throttle'\n    real_T brake;                      // '<Root>/brake'\n  };\n\n  // External outputs (root outports fed by signals with default storage)\n  struct ExtY {\n    real_T speed;                      // '<Root>/speed'\n    real_T RPM;                        // '<Root>/RPM'\n    real_T gear;                       // '<Root>/gear'\n  };\n\n  // Real-time Model Data Structure\n  using odeFSubArray = real_T[2];\n  struct RT_MODEL {\n    const char_T *errorStatus;\n    RTWSolverInfo solverInfo;\n    X *contStates;\n    int_T *periodicContStateIndices;\n    real_T *periodicContStateRanges;\n    real_T *derivs;\n    XDis *contStateDisabled;\n    boolean_T zCCacheNeedsReset;\n    boolean_T derivCacheNeedsReset;\n    boolean_T CTOutputIncnstWithState;\n    real_T odeY[2];\n    real_T odeF[3][2];\n    ODE3_IntgData intgData;\n\n    //\n    //  Sizes:\n    //  The following substructure contains sizes information\n    //  for many of the model attributes such as inputs, outputs,\n    //  dwork, sample times, etc.\n\n    struct {\n      int_T numContStates;\n      int_T numPeriodicContStates;\n      int_T numSampTimes;\n    } Sizes;\n\n    //\n    //  Timing:\n    //  The following substructure contains information regarding\n    //  the timing information for the model.\n\n    struct {\n      uint32_T clockTick0;\n      time_T stepSize0;\n      uint32_T clockTick1;\n      struct {\n        uint8_T TID[3];\n      } TaskCounters;\n\n      time_T tStart;\n      SimTimeStep simTimeStep;\n      boolean_T stopRequestedFlag;\n      time_T *t;\n      time_T tArray[3];\n    } Timing;\n\n    time_T** getTPtrPtr();\n    time_T* getTPtr() const;\n    void setTPtr(time_T* aTPtr);\n    boolean_T isMinorTimeStep() const;\n    boolean_T getStopRequested() const;\n    void setStopRequested(boolean_T aStopRequested);\n    boolean_T isMajorTimeStep() const;\n    boolean_T* getStopRequestedPtr();\n    const char_T** getErrorStatusPtr();\n    time_T getTStart() const;\n    const char_T* getErrorStatus() const;\n    void setErrorStatus(const char_T* const aErrorStatus);\n  };\n\n  // Copy Constructor\n  automatic_transmission(automatic_transmission const&) = delete;\n\n  // Assignment Operator\n  automatic_transmission& operator= (automatic_transmission const&) & = delete;\n\n  // Move Constructor\n  automatic_transmission(automatic_transmission &&) = delete;\n\n  // Move Assignment Operator\n  automatic_transmission& operator= (automatic_transmission &&) = delete;\n\n  // Real-Time Model get method\n  automatic_transmission::RT_MODEL * getRTM();\n\n  // External inputs\n  ExtU rtU;\n\n  // External outputs\n  ExtY rtY;\n\n  // model initialize function\n  void initialize();\n\n  // model step function\n  void step();\n\n  // Constructor\n  automatic_transmission();\n\n  // Destructor\n  ~automatic_transmission();\n\n  // private data and function members\n private:\n  // Block states\n  DW rtDW;\n\n  // Block continuous states\n  X rtX;\n\n  // Block Continuous state disabled vector\n  XDis rtXDis;\n\n  // private member function(s) for subsystem '<Root>'\n  void gear_state(const int32_T *sfEvent);\n\n  // Global mass matrix\n\n  // Continuous states update member function\n  void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si );\n\n  // Derivatives member function\n  void automatic_transmission_derivatives();\n\n  // Real-Time Model\n  RT_MODEL rtM;\n};\n\n// Constant parameters (default storage)\nextern const automatic_transmission::ConstP rtConstP;\n\n//-\n//  These blocks were eliminated from the model due to optimizations:\n//\n//  Block '<Root>/Scope2' : Unused code path elimination\n//  Block '<Root>/Scope1' : Unused code path elimination\n\n\n//-\n//  The generated code includes comments that allow you to trace directly\n//  back to the appropriate location in the model.  The basic format\n//  is <system>/block_name, where system is the system number (uniquely\n//  assigned by Simulink) and block_name is the name of the block.\n//\n//  Use the MATLAB hilite_system command to trace the generated code back\n//  to the model.  For example,\n//\n//  hilite_system('<S3>')    - opens system 3\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n//\n//  Here is the system hierarchy for this model\n//\n//  '<Root>' : 'automatic_transmission'\n//  '<S1>'   : 'automatic_transmission/Engine'\n//  '<S2>'   : 'automatic_transmission/ShiftLogic'\n//  '<S3>'   : 'automatic_transmission/ThresholdCalculation'\n//  '<S4>'   : 'automatic_transmission/Transmission'\n//  '<S5>'   : 'automatic_transmission/Vehicle'\n//  '<S6>'   : 'automatic_transmission/Transmission/TorqueConverter'\n//  '<S7>'   : 'automatic_transmission/Transmission/TransmissionRatio'\n\n#endif                                 // automatic_transmission_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"automatic_transmission_data.cpp","type":"source","group":"data","path":"/Users/ldy/git/sim2cpp/AT/automatic_transmission_ert_rtw","tag":"","groupDisplay":"Data files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: automatic_transmission_data.cpp\n//\n// Code generated for Simulink model 'automatic_transmission'.\n//\n// Model version                  : 15.5\n// Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n// C/C++ source code generated on : Wed Apr  9 13:54:16 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Apple->ARM64\n// Code generation objectives:\n//    1. Execution efficiency\n//    2. RAM efficiency\n// Validation result: Not run\n//\n#include \"automatic_transmission.h\"\n\n// Constant parameters (default storage)\nconst automatic_transmission::ConstP rtConstP{\n  // Expression: downth\n  //  Referenced by: '<S3>/interp_down'\n\n  { 0.0, 5.0, 40.0, 50.0, 90.0, 100.0 },\n\n  // Pooled Parameter (Mixed Expressions)\n  //  Referenced by:\n  //    '<S3>/interp_down'\n  //    '<S3>/interp_up'\n  //    '<S7>/Look-Up Table'\n\n  { 1.0, 2.0, 3.0, 4.0 },\n\n  // Expression: downtab\n  //  Referenced by: '<S3>/interp_down'\n\n  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.0, 5.0, 5.0, 5.0, 30.0, 30.0, 20.0, 20.0,\n    25.0, 30.0, 50.0, 50.0, 35.0, 35.0, 40.0, 50.0, 80.0, 80.0 },\n\n  // Expression: upth\n  //  Referenced by: '<S3>/interp_up'\n\n  { 0.0, 25.0, 35.0, 50.0, 90.0, 100.0 },\n\n  // Expression: uptab\n  //  Referenced by: '<S3>/interp_up'\n\n  { 10.0, 10.0, 15.0, 23.0, 40.0, 40.0, 30.0, 30.0, 30.0, 41.0, 70.0, 70.0, 50.0,\n    50.0, 50.0, 60.0, 100.0, 100.0, 1.0E+6, 1.0E+6, 1.0E+6, 1.0E+6, 1.0E+6,\n    1.0E+6 },\n\n  // Expression: thvec\n  //  Referenced by: '<S1>/EngineTorque'\n\n  { 0.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0 },\n\n  // Expression: nevec\n  //  Referenced by: '<S1>/EngineTorque'\n\n  { 799.99999999999989, 1200.0, 1599.9999999999998, 1999.9999999999998, 2400.0,\n    2800.0000000000005, 3199.9999999999995, 3599.9999999999995,\n    3999.9999999999995, 4400.0, 4800.0 },\n\n  // Expression: emap\n  //  Referenced by: '<S1>/EngineTorque'\n\n  { -40.0, 215.0, 245.0, 264.0, 264.0, 267.0, 267.0, 267.0, 267.0, 267.0, -44.0,\n    117.0, 208.0, 260.0, 279.0, 290.0, 297.0, 301.0, 301.0, 301.0, -49.0, 85.0,\n    178.0, 241.0, 282.0, 293.0, 305.0, 308.0, 312.0, 312.0, -53.0, 66.0, 148.0,\n    219.0, 275.0, 297.0, 305.0, 312.0, 319.0, 319.0, -57.0, 44.0, 122.0, 193.0,\n    260.0, 290.0, 305.0, 319.0, 327.0, 327.0, -61.0, 29.0, 104.0, 167.0, 238.0,\n    275.0, 301.0, 323.0, 327.0, 334.0, -65.0, 10.0, 85.0, 152.0, 223.0, 260.0,\n    293.0, 319.0, 327.0, 334.0, -70.0, -2.0, 66.0, 133.0, 208.0, 256.0, 282.0,\n    316.0, 327.0, 334.0, -74.0, -13.0, 48.0, 119.0, 189.0, 234.0, 267.0, 297.0,\n    312.0, 319.0, -78.0, -22.0, 33.0, 96.0, 171.0, 212.0, 249.0, 279.0, 293.0,\n    305.0, -82.0, -32.0, 18.0, 85.0, 152.0, 193.0, 226.0, 253.0, 267.0, 275.0 },\n\n  // Expression: [2.393 1.450 1.000 0.677]\n  //  Referenced by: '<S7>/Look-Up Table'\n\n  { 2.393, 1.45, 1.0, 0.677 },\n\n  // Pooled Parameter (Expression: speedratio)\n  //  Referenced by:\n  //    '<S6>/FactorK'\n  //    '<S6>/TorqueRatio'\n\n  { 0.0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.60000000000000009,\n    0.70000000000000007, 0.8, 0.81, 0.82000000000000006, 0.83000000000000007,\n    0.84, 0.85, 0.86, 0.87, 0.88, 0.89, 0.9, 0.92, 0.94 },\n\n  // Expression: Kfactor\n  //  Referenced by: '<S6>/FactorK'\n\n  { 137.4652089938063, 137.06501915685197, 135.86444964598905,\n    135.66435472751189, 137.56525645304487, 140.36658531172509,\n    145.26891081441539, 152.87251771654735, 162.97731109964374,\n    164.2779280697452, 166.17882979527823, 167.97968406157264,\n    170.08068070558275, 172.78196210502438, 175.38319604522741,\n    179.58518933324765, 183.58708770279083, 189.89007763482121,\n    197.69377945543027, 215.90241703685155, 244.51599037908485 },\n\n  // Expression: Torkratio\n  //  Referenced by: '<S6>/TorqueRatio'\n\n  { 2.2319999999999998, 2.075, 1.975, 1.8459999999999999, 1.72, 1.564, 1.409,\n    1.254, 1.0959999999999999, 1.08, 1.061, 1.043, 1.028, 1.012, 1.002, 1.002,\n    1.001, 0.998, 0.99900000000000011, 1.001, 1.002 }\n};\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/Users/ldy/git/sim2cpp/AT/automatic_transmission_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtwtypes.h\n//\n// Code generated for Simulink model 'automatic_transmission'.\n//\n// Model version                  : 15.5\n// Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n// C/C++ source code generated on : Wed Apr  9 13:54:16 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Apple->ARM64\n// Code generation objectives:\n//    1. Execution efficiency\n//    2. RAM efficiency\n// Validation result: Not run\n//\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n// Logical type definitions\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n//=======================================================================*\n//  Target hardware information\n//    Device type: Apple->ARM64\n//    Number of bits:     char:   8    short:   16    int:  32\n//                        long:  64    long long:  64\n//                        native word size:  64\n//    Byte ordering: LittleEndian\n//    Signed integer division rounds to: Zero\n//    Shift right on a signed integer as arithmetic shift: on\n// =======================================================================\n\n//=======================================================================*\n//  Fixed width word size data types:                                     *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\n// =======================================================================\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef long int64_T;\ntypedef unsigned long uint64_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n//===========================================================================*\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\n// ===========================================================================\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef unsigned long long ulonglong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n//=======================================================================*\n//  Min and Max:                                                          *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n// =======================================================================\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n\n// Block D-Work pointer type\ntypedef void * pointer_T;\n\n#endif                                 // RTWTYPES_H\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};